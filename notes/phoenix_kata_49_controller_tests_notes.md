# Kata 49: Controller Tests

## What Are Controller Tests?

Controller tests verify that HTTP requests through your Phoenix application produce the correct responses. They use `Phoenix.ConnTest` to simulate the full plug pipeline — routers, plugs, controllers — without starting a real HTTP server or browser.

Think of it like this: instead of opening Chrome and clicking a link, your test calls `get(conn, "/products")` and checks the HTML that comes back.

```elixir
defmodule MyAppWeb.PageControllerTest do
  use MyAppWeb.ConnCase

  test "GET / renders the home page", %{conn: conn} do
    conn = get(conn, ~p"/")
    assert html_response(conn, 200) =~ "Welcome"
  end
end
```

---

## ConnCase — The Foundation

Every controller test starts with `use MyAppWeb.ConnCase`. This module lives in `test/support/conn_case.ex` and is generated by `mix phx.new`. It does three things:

1. Imports `Phoenix.ConnTest` — the HTTP helpers (`get`, `post`, `html_response`, etc.)
2. Sets up the SQL Sandbox — each test runs inside a DB transaction that is rolled back
3. Builds a fresh `%Plug.Conn{}` struct and passes it to your test as `conn`

```elixir
defmodule MyAppWeb.ConnCase do
  use ExUnit.CaseTemplate

  using do
    quote do
      import Phoenix.ConnTest       # get/post/put/delete helpers
      import Plug.Conn              # put_session, put_req_header, etc.
      use MyAppWeb, :verified_routes  # ~p"/path" sigil

      @endpoint MyAppWeb.Endpoint   # ConnTest needs this to dispatch
    end
  end

  setup tags do
    pid = Ecto.Adapters.SQL.Sandbox.start_owner!(
      MyApp.Repo,
      shared: not tags[:async]
    )
    on_exit(fn -> Ecto.Adapters.SQL.Sandbox.stop_owner(pid) end)

    # Every test gets a fresh conn:
    {:ok, conn: Phoenix.ConnTest.build_conn()}
  end
end
```

The `%{conn: conn}` pattern in your test receives this conn. It is a blank `%Plug.Conn{}` struct — no session, no cookies, no headers yet.

---

## HTTP Method Helpers

`Phoenix.ConnTest` provides helpers that mirror HTTP methods. Each one sends a request through the endpoint and returns the response conn:

```elixir
conn = get(conn, ~p"/products")                              # GET
conn = post(conn, ~p"/products", %{product: %{name: "Foo"}}) # POST with body
conn = put(conn, ~p"/products/1", %{product: %{name: "Bar"}}) # PUT
conn = patch(conn, ~p"/products/1/toggle", %{})               # PATCH
conn = delete(conn, ~p"/products/1")                          # DELETE
```

The `~p"/path"` sigil is a verified route — the compiler checks that the route exists.

---

## Response Assertions

After making a request, you assert on the response. These are the core assertion functions:

```elixir
# HTML responses — returns the body string:
assert html_response(conn, 200) =~ "Products"
assert html_response(conn, 200) =~ ~r/Welcome, .+!/

# JSON responses — parses JSON and returns a map:
assert json_response(conn, 200) == %{"id" => 1, "name" => "Foo"}
assert json_response(conn, 201)["name"] == "Foo"

# Plain text responses:
assert text_response(conn, 200) =~ "OK"

# Redirect — returns the Location header:
assert redirected_to(conn) == ~p"/products"
assert redirected_to(conn, 301) == "https://example.com"

# Extract params from redirect path:
assert %{id: id} = redirected_params(conn)
assert redirected_to(conn) == ~p"/products/#{id}"

# Flash messages:
assert Phoenix.Flash.get(conn.assigns.flash, :info) =~ "Created"

# Raw status code:
assert conn.status == 204
```

`html_response(conn, 200)` does two things: asserts the status is 200 AND returns the response body as a string. If the status is wrong, the assertion fails with a clear message.

---

## Testing Form Submissions

Forms POST data as nested maps. Test both the happy path and the error path:

```elixir
describe "create" do
  test "valid params redirects to show page", %{conn: conn} do
    conn = post(conn, ~p"/products", %{
      "product" => %{
        "name" => "Widget",
        "price" => "9.99",
        "description" => "A fine widget"
      }
    })

    # Should redirect to the new product:
    assert %{id: id} = redirected_params(conn)
    assert redirected_to(conn) == ~p"/products/#{id}"

    # Follow the redirect to verify it worked:
    conn = get(recycle(conn), ~p"/products/#{id}")
    assert html_response(conn, 200) =~ "Widget"
  end

  test "invalid params re-renders form with errors", %{conn: conn} do
    conn = post(conn, ~p"/products", %{
      "product" => %{"name" => ""}
    })
    assert html_response(conn, 422) =~ "can't be blank"
  end
end
```

**`recycle(conn)`** creates a new conn while copying cookies and session from the response. Use it when you want to follow a redirect — otherwise the response conn cannot make new requests.

---

## Testing Authenticated Routes

Most apps have routes that require a logged-in user. Use a setup helper to log in before each test:

```elixir
defmodule MyAppWeb.OrderControllerTest do
  use MyAppWeb.ConnCase

  import MyApp.AccountsFixtures

  describe "authenticated access" do
    setup :register_and_log_in_user

    test "lists user's orders", %{conn: conn, user: user} do
      order = OrderFixtures.create_order(user_id: user.id)
      conn = get(conn, ~p"/orders")
      assert html_response(conn, 200) =~ "My Orders"
    end
  end

  describe "unauthenticated access" do
    test "redirects to login page", %{conn: conn} do
      conn = get(conn, ~p"/orders")
      assert redirected_to(conn) == ~p"/users/log_in"
    end
  end
end
```

### The Auth Helper (in ConnCase)

```elixir
# test/support/conn_case.ex — add these functions:
def register_and_log_in_user(%{conn: conn}) do
  user = AccountsFixtures.user_fixture()
  %{conn: log_in_user(conn, user), user: user}
end

defp log_in_user(conn, user) do
  token = MyApp.Accounts.generate_user_session_token(user)
  conn
  |> Phoenix.ConnTest.init_test_session(%{})
  |> Plug.Conn.put_session(:user_token, token)
end
```

The `setup :register_and_log_in_user` line calls this function before each test in the describe block. It creates a user, logs them in by putting a session token on the conn, and makes both `conn` and `user` available to the test.

---

## Testing Authorization

Beyond authentication (is the user logged in?), test authorization (can this user do this action?):

```elixir
test "cannot delete another user's order", %{conn: conn} do
  other_user = AccountsFixtures.user_fixture()
  order = OrderFixtures.create_order(user_id: other_user.id)

  conn = delete(conn, ~p"/orders/#{order.id}")

  assert redirected_to(conn) == ~p"/orders"
  assert Phoenix.Flash.get(conn.assigns.flash, :error) =~ "Not authorized"
end
```

---

## Testing JSON APIs

For API endpoints, set the `accept` header and use `json_response/2`:

```elixir
defmodule MyAppWeb.Api.ProductControllerTest do
  use MyAppWeb.ConnCase

  setup do
    conn = build_conn()
      |> put_req_header("accept", "application/json")
      |> put_req_header("content-type", "application/json")
    {:ok, conn: conn}
  end

  test "GET /api/products returns product list", %{conn: conn} do
    conn = get(conn, ~p"/api/products")
    assert is_list(json_response(conn, 200)["data"])
  end

  test "POST /api/products creates product", %{conn: conn} do
    conn = post(conn, ~p"/api/products", %{
      "product" => %{"name" => "Widget", "price" => 999}
    })
    assert %{"id" => id, "name" => "Widget"} =
             json_response(conn, 201)["data"]
    assert id > 0
  end

  test "POST with invalid data returns 422", %{conn: conn} do
    conn = post(conn, ~p"/api/products", %{
      "product" => %{"name" => ""}
    })
    assert %{"errors" => errors} = json_response(conn, 422)
    assert errors["name"] == ["can't be blank"]
  end
end
```

---

## Testing Headers

```elixir
# Setting request headers:
conn = conn
  |> put_req_header("authorization", "Bearer mytoken")
  |> put_req_header("x-api-key", "secret123")
  |> get(~p"/api/me")

# Asserting response headers:
test "sets JSON content-type", %{conn: conn} do
  conn = get(conn, ~p"/api/products")
  assert get_resp_header(conn, "content-type") ==
           ["application/json; charset=utf-8"]
end
```

---

## Setup and Tags

ExUnit provides `setup` blocks and module tags for controlling test behavior:

```elixir
defmodule MyAppWeb.PostControllerTest do
  use MyAppWeb.ConnCase

  # Runs before EVERY test in this module:
  setup :register_and_log_in_user

  describe "index" do
    test "lists posts", %{conn: conn} do
      conn = get(conn, ~p"/posts")
      assert html_response(conn, 200) =~ "Posts"
    end
  end

  describe "delete" do
    # Additional setup — runs AFTER the module-level setup:
    setup [:create_post]

    test "deletes post", %{conn: conn, post: post} do
      conn = delete(conn, ~p"/posts/#{post}")
      assert redirected_to(conn) == ~p"/posts"
    end
  end

  defp create_post(%{user: user}) do
    post = Blog.create_post!(%{title: "Test", user_id: user.id})
    %{post: post}
  end
end
```

Tags let you include or exclude tests:

```elixir
@tag :slow
test "expensive operation", %{conn: conn} do
  # ...
end

# Run only slow tests:   mix test --only slow
# Skip slow tests:       mix test --exclude slow
```

---

## Key Takeaways

1. **`use MyAppWeb.ConnCase`** sets up ConnTest, DataCase, verified routes, and a fresh conn
2. Each test receives **`%{conn: conn}`** — a blank `%Plug.Conn{}` ready for requests
3. **`get/post/put/patch/delete`** simulate HTTP requests through the full plug pipeline
4. **`html_response/2`** and **`json_response/2`** assert status AND return the body
5. **`recycle(conn)`** copies cookies to a new conn — use it to follow redirects
6. Use **`setup :register_and_log_in_user`** to test authenticated routes
7. Always test **both authenticated and unauthenticated** access to protected routes
8. Controller tests are fast — no HTTP server, no browser, just Elixir processes
