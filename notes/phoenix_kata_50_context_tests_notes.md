# Kata 50: Context Tests

## What Are Context Tests?

Context tests test your application's business logic directly — the context modules like `MyApp.Blog`, `MyApp.Accounts`, `MyApp.Catalog`. They call context functions without going through HTTP, LiveView, or any web layer.

They are the fastest and most precise tests in your suite. If a context test fails, you know exactly which business function is broken.

```elixir
defmodule MyApp.BlogTest do
  use MyApp.DataCase, async: true

  alias MyApp.Blog

  test "create_post/1 creates a post" do
    attrs = %{title: "Hello", body: "World"}
    assert {:ok, post} = Blog.create_post(attrs)
    assert post.title == "Hello"
    # DB changes are rolled back after the test!
  end
end
```

---

## DataCase — The Foundation

`DataCase` lives in `test/support/data_case.ex` and is generated by `mix phx.new`. It wraps each test in a database transaction that is rolled back when the test finishes. This means every test starts with a clean database.

```elixir
defmodule MyApp.DataCase do
  use ExUnit.CaseTemplate

  using do
    quote do
      alias MyApp.Repo
      import Ecto
      import Ecto.Changeset
      import Ecto.Query
      import MyApp.DataCase   # for errors_on/1
    end
  end

  setup tags do
    MyApp.DataCase.setup_sandbox(tags)
    :ok
  end

  def setup_sandbox(tags) do
    pid = Ecto.Adapters.SQL.Sandbox.start_owner!(
      MyApp.Repo,
      shared: not tags[:async]
    )
    ExUnit.Callbacks.on_exit(fn ->
      Ecto.Adapters.SQL.Sandbox.stop_owner(pid)
    end)
  end

  # Converts changeset errors to a simple map:
  def errors_on(changeset) do
    Ecto.Changeset.traverse_errors(changeset, fn {message, opts} ->
      Regex.replace(~r"%{(\w+)}", message, fn _, key ->
        opts |> Keyword.get(String.to_existing_atom(key), key)
             |> to_string()
      end)
    end)
  end
end
```

`DataCase` gives you: `Repo`, `Ecto.Query`, `Ecto.Changeset`, and the `errors_on/1` helper — everything you need to test database-backed logic.

---

## SQL Sandbox — Test Isolation

The SQL Sandbox ensures each test runs in its own database transaction. No test sees another test's data — every INSERT is rolled back after the test. Configure in `config/test.exs`:
```elixir
config :my_app, MyApp.Repo,
  pool: Ecto.Adapters.SQL.Sandbox,
  pool_size: System.schedulers_online() * 2
```

And in `test/test_helper.exs`:

```elixir
Ecto.Adapters.SQL.Sandbox.mode(MyApp.Repo, :manual)
```

The `:manual` mode means each test must check out a connection explicitly — `DataCase.setup_sandbox/1` handles this for you.

---

## Fixtures — Creating Test Data

Fixtures are simple functions that create test records with sensible defaults. Phoenix uses this pattern instead of factory libraries:

```elixir
# test/support/fixtures/blog_fixtures.ex
defmodule MyApp.BlogFixtures do
  alias MyApp.Blog
  alias MyApp.AccountsFixtures

  def post_fixture(attrs \\ %{}) do
    user = AccountsFixtures.user_fixture()

    {:ok, post} =
      attrs
      |> Enum.into(%{
           title: "Test Post #{System.unique_integer()}",
           body: "Some content here",
           published: false,
           user_id: user.id
         })
      |> Blog.create_post()

    post
  end

  def published_post_fixture(attrs \\ %{}) do
    post_fixture(Map.merge(%{published: true}, attrs))
  end
end
```

Usage in tests:

```elixir
import MyApp.BlogFixtures

post = post_fixture()                    # all defaults
post = post_fixture(title: "Custom")     # override one field
post = post_fixture(user_id: user.id)    # use specific user
```

**`System.unique_integer()`** generates a unique number each call — perfect for fields with uniqueness constraints. It avoids collisions when multiple tests create records in parallel.

---

## Test Structure

A well-organized context test groups related tests with `describe` and uses clear naming:

```elixir
defmodule MyApp.AccountsTest do
  use MyApp.DataCase, async: true

  import MyApp.AccountsFixtures
  alias MyApp.Accounts
  alias MyApp.Accounts.User

  describe "get_user!/1" do
    test "returns user for valid id" do
      user = user_fixture()
      assert Accounts.get_user!(user.id) == user
    end

    test "raises for invalid id" do
      assert_raise Ecto.NoResultsError, fn ->
        Accounts.get_user!(99999)
      end
    end
  end

  describe "create_user/1" do
    test "with valid data creates user" do
      attrs = %{email: "test@example.com", password: "twelve_chars!"}
      assert {:ok, %User{} = user} = Accounts.create_user(attrs)
      assert user.email == "test@example.com"
    end

    test "with invalid data returns error changeset" do
      assert {:error, %Ecto.Changeset{}} =
        Accounts.create_user(%{email: "bad"})
    end
  end
end
```

The `describe` block name should match the function being tested. This makes `mix test --trace` output very readable.

---

## Changeset Tests

Testing changesets directly — without going through the context — lets you verify validation rules in isolation:

```elixir
defmodule MyApp.Blog.PostTest do
  use MyApp.DataCase, async: true

  alias MyApp.Blog.Post
  import MyApp.BlogFixtures

  test "valid changeset" do
    changeset = Post.changeset(%Post{}, %{title: "Hello", body: "World"})
    assert changeset.valid?
  end

  test "requires title" do
    changeset = Post.changeset(%Post{}, %{body: "content"})
    refute changeset.valid?
    assert "can't be blank" in errors_on(changeset).title
  end

  test "validates title length" do
    changeset = Post.changeset(%Post{}, %{
      title: String.duplicate("a", 201),
      body: "ok"
    })
    refute changeset.valid?
    assert "should be at most 200 character(s)" in errors_on(changeset).title
  end

  test "enforces unique titles (DB constraint)" do
    post_fixture(title: "Duplicate")

    changeset = Post.changeset(%Post{}, %{
      title: "Duplicate", body: "body"
    })
    {:error, changeset} = Repo.insert(changeset)
    assert "has already been taken" in errors_on(changeset).title
  end
end
```

Note: uniqueness constraints require a `Repo.insert` call because they are enforced at the database level, not in the changeset alone.

---

## The `errors_on/1` Helper

`DataCase` provides `errors_on/1` which converts changeset errors into a simple map of field names to error message lists:

```elixir
changeset = User.changeset(%User{}, %{email: "not-valid"})
errors = errors_on(changeset)
# => %{email: ["is invalid"], password: ["can't be blank"]}

assert "is invalid" in errors.email
assert "can't be blank" in errors.password
refute errors[:name]  # no error on name field
```

Without the helper, raw changeset errors look like `{"can't be blank", [validation: :required]}` — the helper strips the metadata and gives you plain strings.

---

## Context Function Tests — Full CRUD

A complete example testing standard context functions (list, get, create, update, delete):

```elixir
defmodule MyApp.CatalogTest do
  use MyApp.DataCase, async: true

  import MyApp.CatalogFixtures
  alias MyApp.Catalog
  alias MyApp.Catalog.Product

  describe "list_products/0" do
    test "returns all products" do
      p1 = product_fixture(name: "Alpha")
      p2 = product_fixture(name: "Beta")
      assert Catalog.list_products() == [p1, p2]
    end
  end

  describe "create_product/1" do
    test "with valid data" do
      assert {:ok, %Product{} = product} =
        Catalog.create_product(%{name: "Widget", price: 999})
      assert product.name == "Widget"
    end

    test "with invalid price" do
      assert {:error, changeset} =
        Catalog.create_product(%{name: "Widget", price: -1})
      assert "must be greater than 0" in errors_on(changeset).price
    end
  end

  describe "update_product/2" do
    test "with valid data" do
      product = product_fixture()
      assert {:ok, updated} =
        Catalog.update_product(product, %{name: "New Name"})
      assert updated.name == "New Name"
      assert Repo.get!(Product, product.id).name == "New Name"
    end

    test "with invalid data returns error" do
      product = product_fixture()
      assert {:error, %Ecto.Changeset{}} =
        Catalog.update_product(product, %{name: ""})
      assert Repo.get!(Product, product.id).name == product.name
    end
  end

  describe "delete_product/1" do
    test "deletes the product" do
      product = product_fixture()
      assert {:ok, _} = Catalog.delete_product(product)
      assert_raise Ecto.NoResultsError, fn ->
        Catalog.get_product!(product.id)
      end
    end
  end
end
```

---

## Async Tests and Running Tests

Context tests are ideal for `async: true` because each test gets its own isolated DB transaction:

```elixir
defmodule MyApp.AccountsTest do
  use MyApp.DataCase, async: true   # runs in parallel with other async modules
end
```

**Use `async: true` when**: tests only interact with the database and do not modify global state (ETS, files, `Application.put_env`).

**Avoid `async: true` when**: tests modify global configuration or depend on execution order.

Common `mix test` commands:

```bash
mix test                                # run all tests
mix test test/my_app/blog_test.exs      # one file
mix test test/my_app/blog_test.exs:42   # one test (by line number)
mix test --trace                        # verbose — shows each test name
mix test --seed 0                       # deterministic order
mix test --max-failures 3               # stop after 3 failures
```

---

## Key Takeaways

1. **`use MyApp.DataCase`** wraps each test in a rolled-back DB transaction — clean slate every time
2. **`async: true`** runs context tests in parallel — the SQL Sandbox handles isolation
3. **Fixtures** are simple functions that create test data with sensible defaults
4. Use **`System.unique_integer()`** in fixtures for fields with uniqueness constraints
5. **`errors_on/1`** converts changeset errors to a simple `%{field: [messages]}` map
6. Test **happy paths and error paths** for every context function
7. Test **changesets directly** to verify validation rules in isolation
8. Use **`describe`** blocks named after the function being tested for clear structure
