# Kata 36: Repo Basics

## What is Repo?

`Repo` is the process that manages the database connection pool. It is the **only** way to persist data in Ecto — you cannot insert or query without going through it.

```elixir
# Defined in lib/my_app/repo.ex (generated by mix phx.new):
defmodule MyApp.Repo do
  use Ecto.Repo,
    otp_app: :my_app,
    adapter: Ecto.Adapters.Postgres
end
```

It is started as a supervised process in `lib/my_app/application.ex`:

```elixir
children = [
  MyApp.Repo,
  MyAppWeb.Endpoint,
  ...
]
```

---

## Repo Function Reference

| Function | Returns | Raises version | Purpose |
|----------|---------|----------------|---------|
| `Repo.insert/2` | `{:ok, struct}` or `{:error, changeset}` | `insert!/2` | Insert changeset or struct |
| `Repo.get/3` | `struct` or `nil` | `get!/3` | Find by primary key |
| `Repo.get_by/3` | `struct` or `nil` | `get_by!/3` | Find by field/value |
| `Repo.all/2` | `[struct]` | — | Return all matching |
| `Repo.one/2` | `struct` or `nil` | `one!/2` | Exactly one result |
| `Repo.update/2` | `{:ok, struct}` or `{:error, changeset}` | `update!/2` | Update changeset |
| `Repo.delete/2` | `{:ok, struct}` or `{:error, changeset}` | `delete!/2` | Delete struct |
| `Repo.insert_all/3` | `{count, nil}` or `{count, rows}` | — | Bulk insert |
| `Repo.update_all/3` | `{count, nil}` | — | Bulk update |
| `Repo.delete_all/2` | `{count, nil}` | — | Bulk delete |
| `Repo.exists?/2` | `boolean` | — | Check if any match |
| `Repo.aggregate/4` | value or `nil` | — | count/sum/avg/min/max |
| `Repo.transaction/2` | `{:ok, result}` or `{:error, ...}` | — | Run in a transaction |

---

## Insert

```elixir
# Via changeset (recommended — validates first):
changeset = User.registration_changeset(%User{}, attrs)

case Repo.insert(changeset) do
  {:ok, user} ->
    # user.id is populated with DB-generated value
    user

  {:error, changeset} ->
    # changeset.errors has all failures
    changeset.errors
end

# Bang version (raises on error):
user = Repo.insert!(changeset)

# Insert a bare struct (bypasses changeset validation):
{:ok, user} = Repo.insert(%User{email: "alice@example.com"})
```

### Returning Fields

```elixir
{:ok, user} = Repo.insert(changeset, returning: [:id, :inserted_at])
```

### Upsert (On Conflict)

```elixir
# Skip if duplicate:
Repo.insert(changeset, on_conflict: :nothing)

# Update specific fields if conflict on :email:
Repo.insert(changeset,
  on_conflict: {:replace, [:username, :updated_at]},
  conflict_target: :email)

# Replace all fields:
Repo.insert(changeset, on_conflict: :replace_all)
```

### insert_or_update

Inserts if the struct is new (not fetched from DB), updates if it was:

```elixir
changeset =
  case Repo.get_by(User, email: email) do
    nil  -> User.changeset(%User{}, attrs)
    user -> User.changeset(user, attrs)
  end

{:ok, user} = Repo.insert_or_update(changeset)
```

### insert_all (Bulk)

Bypasses changesets — for high-volume inserts:

```elixir
now = NaiveDateTime.truncate(NaiveDateTime.utc_now(), :second)

Repo.insert_all(User, [
  %{email: "a@x.com", username: "a",
    inserted_at: now, updated_at: now},
  %{email: "b@x.com", username: "b",
    inserted_at: now, updated_at: now}
])
# => {2, nil}
```

---

## Read

### By Primary Key

```elixir
user = Repo.get(User, 42)      # nil if not found
user = Repo.get!(User, 42)     # raises Ecto.NoResultsError if nil
```

### By Fields

```elixir
user = Repo.get_by(User, email: "alice@example.com")
user = Repo.get_by(User, [email: "alice@example.com", role: "admin"])
user = Repo.get_by!(User, email: "alice@example.com")  # raises if nil
```

### All Records

```elixir
# All rows in the table:
users = Repo.all(User)

# With a query:
import Ecto.Query

admins = Repo.all(
  from u in User,
    where: u.role == "admin",
    order_by: [asc: u.username]
)
```

### One (Expects Exactly One)

```elixir
query = from u in User, where: u.email == "alice@example.com"

user = Repo.one(query)   # nil if 0, raises if >1
user = Repo.one!(query)  # raises if 0 or >1
```

### Exists?

```elixir
has_admin = Repo.exists?(from u in User, where: u.role == "admin")
# => true or false
```

### Aggregate

```elixir
count    = Repo.aggregate(User, :count)
total    = Repo.aggregate(Order, :sum, :total_cents)
avg      = Repo.aggregate(Product, :avg, :price)
youngest = Repo.aggregate(User, :min, :age)
oldest   = Repo.aggregate(User, :max, :age)
```

---

## Update

Update requires fetching the record first, then building a changeset from it:

```elixir
user = Repo.get!(User, 42)

changeset = User.profile_changeset(user, %{username: "alice_v2"})

case Repo.update(changeset) do
  {:ok, updated_user}  -> updated_user
  {:error, changeset}  -> changeset.errors
end

# Bang version:
updated = Repo.update!(changeset)
```

### Bulk Update (No Changesets)

```elixir
import Ecto.Query

# Set a field on all matching rows:
{count, _} = Repo.update_all(
  from(u in User, where: u.role == "member"),
  set: [verified: true]
)

# Increment a field:
Repo.update_all(Post, inc: [view_count: 1])

# Push to array (Postgres only):
Repo.update_all(User, push: [tags: "elixir"])
```

---

## Delete

```elixir
user = Repo.get!(User, 42)

case Repo.delete(user) do
  {:ok, deleted_user}  -> "Deleted #{deleted_user.id}"
  {:error, changeset}  -> changeset.errors  # FK constraint, etc.
end

# Bang version:
Repo.delete!(user)
```

### Bulk Delete

```elixir
import Ecto.Query

{count, _} = Repo.delete_all(
  from u in User,
    where: u.verified == false
      and u.inserted_at < ^cutoff_date
)
```

---

## Transactions

```elixir
# Simple transaction:
Repo.transaction(fn ->
  {:ok, user} = Repo.insert(user_changeset)
  {:ok, _log} = Repo.insert(audit_changeset)
  user  # last value becomes {:ok, user}
end)
# => {:ok, user}

# Rollback on error:
Repo.transaction(fn ->
  {:ok, user} = Repo.insert(user_changeset)
  Repo.transaction_rollback(:something_went_wrong)
end)
# => {:error, :something_went_wrong}
```

### Ecto.Multi (Structured Transactions)

`Ecto.Multi` names each operation and returns detailed error info:

```elixir
Ecto.Multi.new()
|> Ecto.Multi.insert(:user, user_changeset)
|> Ecto.Multi.insert(:profile, fn %{user: user} ->
     Profile.changeset(%Profile{}, %{user_id: user.id})
   end)
|> Ecto.Multi.run(:welcome_email, fn _repo, %{user: user} ->
     Mailer.send_welcome(user)
     {:ok, :sent}
   end)
|> Repo.transaction()

# On success:
# => {:ok, %{user: user, profile: profile, welcome_email: :sent}}

# On failure at :profile step:
# => {:error, :profile, failed_changeset,
#      %{user: inserted_user}}
```

---

## Preloading Associations

When you fetch a record, its associations are NOT loaded by default (they are `%Ecto.Association.NotLoaded{}`). Use `preload`:

```elixir
# At query time:
user = Repo.get!(User, 42) |> Repo.preload(:posts)
user = Repo.preload(user, [:posts, :comments])

# In the query itself:
import Ecto.Query

user = Repo.one(
  from u in User,
    where: u.id == 42,
    preload: [:posts]
)

# Nested preloads:
user = Repo.preload(user, posts: :comments)
```

---

## Safe vs Bang Pattern

Use safe versions in controllers and contexts. Use bang in scripts and tests:

```elixir
# Context function — safe:
def get_user(id) do
  Repo.get(User, id)  # returns nil if not found
end

def get_user!(id) do
  Repo.get!(User, id)  # raises if not found
end

# Controller — match on result:
case Accounts.create_user(params) do
  {:ok, user}        -> redirect to user page
  {:error, changeset} -> render form with errors
end
```

---

## Key Takeaways

1. **Repo** is the single gateway to the database — all DB operations go through it
2. Use **changesets** with `insert/update` to get validation; use `insert_all/update_all/delete_all` for bulk operations that bypass changesets
3. **Bang functions** (`get!`, `insert!`, etc.) raise exceptions — use in scripts/tests, not in user-facing code
4. Always fetch a record before updating or deleting it (Ecto requires the original struct)
5. Use **transactions** for multi-step operations that must succeed or fail together
6. **Ecto.Multi** is preferred over plain transactions for named, structured multi-step operations
7. Associations are **not loaded by default** — use `Repo.preload/2` to fetch them
